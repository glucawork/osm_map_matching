---
title: 'osm_map_matching: a QGIS plugin for efficient map-matching with OpenStreetMap data'
tags:
  - qgis plugin
  - map-matching
  - openstreetmap
  - python
authors:
  - name: Gianluca Rossi
    orcid: 0000-0002-6440-8203
    equal-contrib: true
affiliations:
 - name: Universit√† di Tor Vergata - Roma, Italy
date: 12 July 2024
bibliography: paper.bib

---

# Summary

In the map-matching problem, a sequence of geographic positions, typically obtained from GPS data, must be aligned with the routes depicted in a digital map. The aim is to accurately determine the most likely route taken by a moving object, such as a vehicle or pedestrian, by matching the observed data points with the roads or pathways described by the map.

`osm-map-matching` is a Python-based QGIS plugin [@QGIS] designed to match an input vector layer of observed geographic positions with corresponding routes from OpenStreetMap (OSM) [@OSM]. The output is a vector layer containing linestrings that represent the matched routes. Each linestring in the vector corresponds to a continuous segment characterized by consistent features extracted from the map data.

The solution used employs a topology-based algorithm that calculates the shortest path from points in the road network that have specific proximity characteristics to the input points. This resulting algorithm is significantly faster than others [@Duffield2022, @Jung2019] without sacrificing the quality of the solutions.

# Statement of need

As far as we know there exist three map matching plugin for QGIS, *Offline-MapMatching* [@Jung2019], *Assisted-MapMatching* [@Gelb], and *Here Route API Plugin* [@here].

The first two plugins use Hidden Markov Models, which are known for their high time complexity [@newson2009hidden], leading to long execution times. The third plugin is an interface for the HERE routing service. It requires registration, is not open source, and has a limit of 10,000 points. Additionally, we were unable to fully get the first two plugins to work, possibly due to lack of maintenance as they have not been updated in the past two years.

Our plugin is fully open source, with no usage restrictions. Its algorithm, which is based on calculating shortest path trees over very small portions of the road network graph, makes it extremely fast.

# Functionality

Once the plugin is launched, a vector layer of points, `points_vector`, describing the route to be mapped should be provided along with two numerical parameters: `max_dist` and `min_loop_size`. The `max_dist` parameter specifies the maximum allowable distance between a point in the vector layer and its corresponding element on the map. The `min_loop_size` parameter is used during the final route cleaning phase to remove small loops from the route that are shorter than this parameter's value.

The plugin generates a route on the OSM graph based on the input vector layer. The output is a vector layer consisting of consecutive linestrings. Each linestring represents a segment of the route as a sequence of points and with additional fields providing details about the segment's attributes, which are sourced from OSM data. The table below provides an excerpt from the *attribute table* of a linesting vector layer generated by the plugin. Each row represents a linestring description, with the columns detailing the attributes. Besides the ID assigned by OSM, the only attribute consistently present is `highway`, which indicates the type of street, road or path in OSM.

|osm_id|name|lanes|access|surface|oneway|highway|
|----|----|----|----|----|----|----|
|122411452|Via Appia Nuova|2||asphalt|yes|primary|
|25775100|Via Latina|1||asphalt|yes|residential|
|842258282||||||footway|
|27668251|Viale Mario Leigheb||agricultural|unpaved||track|
|35125987||||ground||path|
|35125959||||ground||path|
|842258285||||||footway|
|27527220|Via Franco Bartoloni|||asphalt|yes|residential|
|123415114|||private|||service|

\autoref{fig:routerepr}  illustrates a graphical representation of the `highway` field. Dashed lines are used for values such as `path`, `footway`, and `steps`, whereas a solid line represents all other values.

![A graphical representation of the `highway` field.\label{fig:routerepr}](pictures/caffarella.jpg){ width=60% }

Moreover, starting from the plugin output, it is possible to create a clear and concise presentation of the data through straightforward operations in the QGIS environment


| `highway`    | `min` | `max` | `sum` | `mean`    |
|------------|-----|-----|-----|--------------|
| `primary`    | 67  | 74  | 141 | 70.5         |
| `residential`| 24  | 290 | 816 | 116.57       |
| `footway`    | 2   | 22  | 47  | 11.75        |
| `track`      | 99  | 298 | 397 | 198.5        |
| `path`       | 13  | 381 | 585 | 117          |
| `service`    | 10  | 78  | 88  | 44           |
| `steps`      | 19  | 19  | 19  | 19           |



This table provides a summary of the lengths in meters for each highway type.

# Algorithm description

OpenStreetMap data consists of *nodes*, *ways*, and *tags*. Nodes are points with geographic coordinates. Ways are sequences of nodes that describe linear features like roads or paths. Tags are key-value pairs that describe attributes, such as `highway=residential` for a residential road.

After selecting the input vector layer (`points_vector`) and specifying the two numerical parameters (`max_dist` and `min_loop_size`), the algorithm retrieves the OSM map section that includes the `points_vector`. It then constructs the road graph $G$ using the NetworkX library  [@networkx], labeling the edges of $G$ with tags extracted from OSM ways.

At each iteration, the algorithm attempts to match each point in `points_vector` with a node in $G$. Let $p$ be the last matched point and $v_p$ the corresponding node in $G$, and let $q$ be the next point to be matched. The algorithm computes the shortest path tree $T_p$ in $G$, rooted at $v_p$. It then searches for the edge $e_q$ in $T_p$ that is closest to $q$ and matches $q$ to the node $v_q$ of $e_q$ that is nearest to $q$. Finally, the nodes that belong to the shortest path from $v_p$ and $v_q$ are added to the solution and the algorithm continue from node $v_q$.

![How the algorithm works.\label{fig:shortestpath}](pictures/shortest_path.png){ width=60% }

The picture illustrates an example of how the algorithm works. The green edges represent the shortest path tree from node $v_p$, while the black edge is another graph edge. The blue arrows highlight the shortest path from $v_p$ to $v_q$. Nodes $a$, $b$, and $v_q$ are added to the solution, and the algorithm proceeds by computing a shortest path tree from $v_q$.

In the case where the distance between $q$ and $e_q$ is greater than `max_dist`, a dummy node is inserted into the solution instead of the shortest path between $p$ and $v_q$. Dummy nodes will be added in the same way until an edge is found whose distance from the current node is smaller than `max_dist`.

## Optimizations

Since the area covering the entire input vector layer can be extensive, smaller portions of the graph (at most one square kilometer) are downloaded along the input path, and the algorithm operates on these smaller graphs. This approach reduces memory usage and enhances performance.

Calculating the shortest distances to nodes that are too far from the root relative to $q$ is inefficient. To enhance performance, the construction of the shortest path trees are stopped when the distances exceed a cut-off value set at $1.5 \cdot \text{distance}(v_p, q)$.


# Referencess
